
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>controller: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kuzhukin/metrics-collector/internal/agent/controller/controller.go (94.9%)</option>
				
				<option value="file1">github.com/kuzhukin/metrics-collector/internal/server/handler/get_list_handler.go (0.0%)</option>
				
				<option value="file2">github.com/kuzhukin/metrics-collector/internal/server/handler/ping_handler.go (0.0%)</option>
				
				<option value="file3">github.com/kuzhukin/metrics-collector/internal/server/handler/response.go (36.8%)</option>
				
				<option value="file4">github.com/kuzhukin/metrics-collector/internal/server/handler/update_batch_handler.go (0.0%)</option>
				
				<option value="file5">github.com/kuzhukin/metrics-collector/internal/server/handler/update_handler.go (92.3%)</option>
				
				<option value="file6">github.com/kuzhukin/metrics-collector/internal/server/handler/value_handler.go (0.0%)</option>
				
				<option value="file7">github.com/kuzhukin/metrics-collector/internal/server/parser/parser_impl.go (40.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package controller

import (
        "fmt"
        "math/rand"
        "runtime"
        "sync"
        "time"

        "github.com/kuzhukin/metrics-collector/internal/agent/reporter"
        "github.com/kuzhukin/metrics-collector/internal/zlog"
        "github.com/shirou/gopsutil/v3/cpu"
        "github.com/shirou/gopsutil/v3/mem"
)

type Controller struct {
        wg             sync.WaitGroup
        polingInterval int
        reportInterval int

        metricsLock    sync.Mutex
        gaugeMetrics   map[string]float64
        counterMetrics map[string]int64

        reporter reporter.Reporter

        done chan struct{}
}

func New(reporter reporter.Reporter, pollingInterval, reportInterval int) *Controller <span class="cov8" title="1">{
        return &amp;Controller{
                polingInterval: pollingInterval,
                reportInterval: reportInterval,
                gaugeMetrics:   make(map[string]float64),
                counterMetrics: make(map[string]int64),
                reporter:       reporter,
                done:           make(chan struct{}),
        }
}</span>

func (c *Controller) Start() <span class="cov8" title="1">{
        zlog.Logger.Infof("Controller started")
        c.start()
        zlog.Logger.Infof("Controller stopped")
}</span>

func (c *Controller) Stop() <span class="cov8" title="1">{
        close(c.done)
}</span>

func (c *Controller) start() <span class="cov8" title="1">{
        c.startCollector()
        c.startReporter()
        c.startGoPsUtilCollector()

        c.wg.Wait()
}</span>

func (c *Controller) startCollector() <span class="cov8" title="1">{
        c.wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer c.wg.Done()

                pollingTicker := time.NewTicker(time.Second * time.Duration(c.polingInterval))
                defer pollingTicker.Stop()

                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-pollingTicker.C:<span class="cov8" title="1">
                                c.collectMetrics()</span>
                        case &lt;-c.done:<span class="cov8" title="1">
                                return</span>
                        }
                }
        }()
}

func (c *Controller) startGoPsUtilCollector() <span class="cov8" title="1">{
        c.wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer c.wg.Done()

                pollingTicker := time.NewTicker(time.Second * time.Duration(c.polingInterval))
                defer pollingTicker.Stop()

                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-pollingTicker.C:<span class="cov8" title="1">
                                c.collectGoPsUtilMetrics()</span>
                        case &lt;-c.done:<span class="cov8" title="1">
                                return</span>
                        }
                }
        }()
}

func (c *Controller) startReporter() <span class="cov8" title="1">{
        c.wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer c.wg.Done()

                reportTicker := time.NewTicker(time.Second * time.Duration(c.reportInterval))
                defer reportTicker.Stop()

                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-reportTicker.C:<span class="cov0" title="0">
                                c.reporter.Report(c.getMetrics())</span>
                        case &lt;-c.done:<span class="cov8" title="1">
                                return</span>
                        }
                }
        }()
}

func (c *Controller) collectMetrics() <span class="cov8" title="1">{

        c.collectGauge()
        c.collectCounter()
}</span>

func (c *Controller) collectGauge() <span class="cov8" title="1">{
        memstats := &amp;runtime.MemStats{}
        runtime.ReadMemStats(memstats)

        c.metricsLock.Lock()
        defer c.metricsLock.Unlock()

        c.addGauge("Alloc", float64(memstats.Alloc))
        c.addGauge("BuckHashSys", float64(memstats.BuckHashSys))
        c.addGauge("Frees", float64(memstats.Frees))
        c.addGauge("GCCPUFraction", memstats.GCCPUFraction)
        c.addGauge("GCSys", float64(memstats.GCSys))
        c.addGauge("HeapAlloc", float64(memstats.HeapAlloc))
        c.addGauge("HeapIdle", float64(memstats.HeapIdle))
        c.addGauge("HeapInuse", float64(memstats.HeapInuse))
        c.addGauge("HeapObjects", float64(memstats.HeapObjects))
        c.addGauge("HeapReleased", float64(memstats.HeapReleased))
        c.addGauge("HeapSys", float64(memstats.HeapSys))
        c.addGauge("LastGC", float64(memstats.LastGC))
        c.addGauge("Lookups", float64(memstats.Lookups))
        c.addGauge("MCacheInuse", float64(memstats.MCacheInuse))
        c.addGauge("MCacheSys", float64(memstats.MCacheSys))
        c.addGauge("MSpanInuse", float64(memstats.MSpanInuse))
        c.addGauge("MSpanSys", float64(memstats.MSpanSys))
        c.addGauge("Mallocs", float64(memstats.Mallocs))
        c.addGauge("NextGC", float64(memstats.NextGC))
        c.addGauge("NumForcedGC", float64(memstats.NumForcedGC))
        c.addGauge("NumGC", float64(memstats.NumGC))
        c.addGauge("OtherSys", float64(memstats.OtherSys))
        c.addGauge("PauseTotalNs", float64(memstats.PauseTotalNs))
        c.addGauge("StackInuse", float64(memstats.StackInuse))
        c.addGauge("StackSys", float64(memstats.StackSys))
        c.addGauge("Sys", float64(memstats.Sys))
        c.addGauge("TotalAlloc", float64(memstats.TotalAlloc))

        // random value
        c.addGauge("RandomValue", genRandom())
}</span>

func (c *Controller) collectGoPsUtilMetrics() <span class="cov8" title="1">{
        v, err := mem.VirtualMemory()
        if err != nil </span><span class="cov0" title="0">{
                zlog.Logger.Errorf("read gosputil virt mem, err=%s", err)
                return
        }</span>

        <span class="cov8" title="1">utils, err := cpu.Percent(time.Second, true)
        if err != nil </span><span class="cov0" title="0">{
                zlog.Logger.Errorf("read gosputil virt mem, err=%s", err)
                return
        }</span>

        <span class="cov8" title="1">c.metricsLock.Lock()
        defer c.metricsLock.Unlock()

        c.addGauge("TotalMemory", float64(v.Total))
        c.addGauge("FreeMemory", float64(v.Free))

        for i, percent := range utils </span><span class="cov8" title="1">{
                c.addGauge(fmt.Sprintf("CPUutilization%d", i), percent)
        }</span>

}

func (c *Controller) addGauge(name string, value float64) <span class="cov8" title="1">{
        c.gaugeMetrics[name] = value
}</span>

func (c *Controller) collectCounter() <span class="cov8" title="1">{
        c.metricsLock.Lock()
        defer c.metricsLock.Unlock()

        c.counterMetrics["PollCount"]++
}</span>

func genRandom() float64 <span class="cov8" title="1">{
        return rand.Float64()
}</span>

func (c *Controller) getMetrics() (map[string]float64, map[string]int64) <span class="cov8" title="1">{
        c.metricsLock.Lock()
        defer c.metricsLock.Unlock()

        gauges := make(map[string]float64, len(c.gaugeMetrics))
        counters := make(map[string]int64, len(c.counterMetrics))

        for k, v := range c.gaugeMetrics </span><span class="cov8" title="1">{
                gauges[k] = v
        }</span>

        <span class="cov8" title="1">for k, v := range c.counterMetrics </span><span class="cov8" title="1">{
                counters[k] = v
        }</span>

        <span class="cov8" title="1">return gauges, counters</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package handler

import (
        "net/http"

        "github.com/kuzhukin/metrics-collector/internal/server/codec"
        "github.com/kuzhukin/metrics-collector/internal/server/endpoint"
        "github.com/kuzhukin/metrics-collector/internal/server/storage"
        "github.com/kuzhukin/metrics-collector/internal/zlog"
)

var _ http.Handler = &amp;GetListHandler{}

type GetListHandler struct {
        storage storage.Storage
}

func NewGetListHandler(storage storage.Storage) *GetListHandler <span class="cov0" title="0">{
        return &amp;GetListHandler{
                storage: storage,
        }
}</span>

func (u *GetListHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                zlog.Logger.Infof("Endpoint %s supports only GET method", endpoint.ValueEndpoint)
                w.WriteHeader(http.StatusMethodNotAllowed)

                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "text/html")

        metrics, err := u.storage.List(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)

        decoded := codec.DecodeMetricsList(metrics)
        _, err = w.Write([]byte(decoded))
        if err != nil </span><span class="cov0" title="0">{
                zlog.Logger.Errorf("Write data to response, err=%s", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handler

import (
        "net/http"

        "github.com/kuzhukin/metrics-collector/internal/server/storage/dbstorage"
)

type PingHandler struct {
        db *dbstorage.DBStorage
}

func NewPingHandler(db *dbstorage.DBStorage) *PingHandler <span class="cov0" title="0">{
        return &amp;PingHandler{
                db: db,
        }
}</span>

func (h *PingHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">if h.db == nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !h.db.CheckConnection(r.Context()) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handler

import (
        "fmt"
        "net/http"

        "github.com/kuzhukin/metrics-collector/internal/metric"
        "github.com/kuzhukin/metrics-collector/internal/server/codec"
)

func response(w http.ResponseWriter, r *http.Request, metric *metric.Metric) error <span class="cov8" title="1">{
        switch r.Header.Get("Content-Type") </span>{
        case "application/json":<span class="cov0" title="0">
                return responseJSON(w, r, metric)</span>
        default:<span class="cov8" title="1">
                return responseTextPlain(w, r, metric)</span>
        }
}

func responseJSON(w http.ResponseWriter, r *http.Request, m *metric.Metric) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)

        var data []byte
        var err error

        data, err = m.Serialize()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("serializa metric err=%w", err)
        }</span>

        <span class="cov0" title="0">if _, err := w.Write(data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write data err=%w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func responseTextPlain(w http.ResponseWriter, r *http.Request, metric *metric.Metric) error <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "text/plain")
        w.WriteHeader(http.StatusOK)

        decodedValue := codec.DecodeValue(metric)
        if _, err := w.Write([]byte(decodedValue)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write data, err=%w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handler

import (
        "errors"
        "net/http"

        "github.com/kuzhukin/metrics-collector/internal/server/codec"
        "github.com/kuzhukin/metrics-collector/internal/server/parser"
        "github.com/kuzhukin/metrics-collector/internal/server/storage"
        "github.com/kuzhukin/metrics-collector/internal/zlog"
)

var _ http.Handler = &amp;BatchUpdateHandler{}

type BatchUpdateHandler struct {
        storage storage.Storage
        parser  parser.BatchRequestParser
}

func NewBatchUpdateHandler(storage storage.Storage, parser parser.BatchRequestParser) *BatchUpdateHandler <span class="cov0" title="0">{
        return &amp;BatchUpdateHandler{
                storage: storage,
                parser:  parser,
        }
}</span>

func (h *BatchUpdateHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">metrics, err := h.parser.BatchParse(r)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, parser.ErrMetricNameIsNotFound) </span><span class="cov0" title="0">{
                        zlog.Logger.Warnf("Metric wasn't found path=%s, err=%s", r.URL.Path, err)
                        w.WriteHeader(http.StatusNotFound)
                }</span> else<span class="cov0" title="0"> if errors.Is(err, codec.ErrBadMetricValue) </span><span class="cov0" title="0">{
                        zlog.Logger.Warnf("Bad metric value path=%s, err=%s", r.URL.Path, err)
                        w.WriteHeader(http.StatusBadRequest)
                }</span> else<span class="cov0" title="0"> if errors.Is(err, parser.ErrBadMetricKind) </span><span class="cov0" title="0">{
                        zlog.Logger.Warnf("Bad metric kind path=%s, err=%s", r.URL.Path, err)
                        w.WriteHeader(http.StatusBadRequest)
                }</span> else<span class="cov0" title="0"> {
                        zlog.Logger.Warnf("Parse request path=%s, err=%s", r.URL.Path, err)
                        w.WriteHeader(http.StatusBadRequest)
                }</span>

                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if err := h.storage.BatchUpdate(r.Context(), metrics); err != nil </span><span class="cov0" title="0">{
                zlog.Logger.Errorf("batch updater metrics err=%s\n", err)
                w.WriteHeader(http.StatusInternalServerError)

                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handler

import (
        "errors"
        "net/http"

        "github.com/kuzhukin/metrics-collector/internal/server/codec"
        "github.com/kuzhukin/metrics-collector/internal/server/endpoint"
        "github.com/kuzhukin/metrics-collector/internal/server/parser"
        "github.com/kuzhukin/metrics-collector/internal/server/storage"
        "github.com/kuzhukin/metrics-collector/internal/zlog"
)

var _ http.Handler = &amp;UpdateHandler{}

type UpdateHandler struct {
        storage storage.Storage
        parser  parser.RequestParser
}

func NewUpdateHandler(storage storage.Storage, parser parser.RequestParser) *UpdateHandler <span class="cov8" title="1">{
        return &amp;UpdateHandler{
                storage: storage,
                parser:  parser,
        }
}</span>

func (u *UpdateHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                zlog.Logger.Infof("Endpoint %s supports only POST method", endpoint.UpdateEndpoint)
                w.WriteHeader(http.StatusMethodNotAllowed)

                return
        }</span>

        <span class="cov8" title="1">metric, err := u.parser.Parse(r)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, parser.ErrMetricNameIsNotFound) </span><span class="cov8" title="1">{
                        zlog.Logger.Warnf("Metric wasn't found path=%s, err=%s", r.URL.Path, err)
                        w.WriteHeader(http.StatusNotFound)
                }</span> else<span class="cov8" title="1"> if errors.Is(err, codec.ErrBadMetricValue) </span><span class="cov8" title="1">{
                        zlog.Logger.Warnf("Bad metric value path=%s, err=%s", r.URL.Path, err)
                        w.WriteHeader(http.StatusBadRequest)
                }</span> else<span class="cov8" title="1"> if errors.Is(err, parser.ErrBadMetricKind) </span><span class="cov8" title="1">{
                        zlog.Logger.Warnf("Bad metric kind path=%s, err=%s", r.URL.Path, err)
                        w.WriteHeader(http.StatusBadRequest)
                }</span> else<span class="cov8" title="1"> {
                        zlog.Logger.Warnf("Parse request path=%s, err=%s", r.URL.Path, err)
                        w.WriteHeader(http.StatusBadRequest)
                }</span>

                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">if err := u.storage.Update(r.Context(), metric); err != nil </span><span class="cov8" title="1">{
                zlog.Logger.Errorf("Metrics=%v updating err=%s\n", metric, err)
                w.WriteHeader(http.StatusInternalServerError)

                return
        }</span>

        <span class="cov8" title="1">if err := response(w, r, metric); err != nil </span><span class="cov0" title="0">{
                zlog.Logger.Warnf("response metric=%v, err=%s", *metric, err)
                http.Error(w, "internal error", http.StatusInternalServerError)
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handler

import (
        "net/http"

        "github.com/kuzhukin/metrics-collector/internal/server/endpoint"
        "github.com/kuzhukin/metrics-collector/internal/server/parser"
        "github.com/kuzhukin/metrics-collector/internal/server/storage"
        "github.com/kuzhukin/metrics-collector/internal/zlog"
)

var _ http.Handler = &amp;ValueHandler{}

type ValueHandler struct {
        storage storage.Storage
        parser  parser.RequestParser
}

func NewValueHandler(storage storage.Storage, parser parser.RequestParser) *ValueHandler <span class="cov0" title="0">{
        return &amp;ValueHandler{
                storage: storage,
                parser:  parser,
        }
}</span>

func (u *ValueHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet &amp;&amp; r.Method != http.MethodPost </span><span class="cov0" title="0">{
                zlog.Logger.Infof("Endpoint %s supports only GET method", endpoint.ValueEndpoint)
                w.WriteHeader(http.StatusMethodNotAllowed)

                return
        }</span>

        <span class="cov0" title="0">metric, err := u.parser.Parse(r)
        if err != nil </span><span class="cov0" title="0">{
                zlog.Logger.Warnf("Parse request path=%s, err=%s", r.URL.Path, err)
                w.WriteHeader(http.StatusBadRequest)

                return
        }</span>

        <span class="cov0" title="0">storedMetric, err := u.storage.Get(r.Context(), metric.Type, metric.ID)
        if err != nil </span><span class="cov0" title="0">{
                zlog.Logger.Errorf("storage get kind=%s, name=%s err=%s", metric.Type, metric.ID, err)
                w.WriteHeader(http.StatusNotFound)

                return
        }</span>

        <span class="cov0" title="0">if err := response(w, r, storedMetric); err != nil </span><span class="cov0" title="0">{
                zlog.Logger.Warnf("response metric=%v, err=%s", *storedMetric, err)
                http.Error(w, "internal error", http.StatusInternalServerError)
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package parser

import (
        "errors"
        "fmt"
        "io"
        "net/http"

        "github.com/go-chi/chi/v5"
        "github.com/kuzhukin/metrics-collector/internal/metric"
        "github.com/kuzhukin/metrics-collector/internal/server/codec"
)

var _ RequestParser = &amp;parserImpl{}
var _ BatchRequestParser = &amp;parserImpl{}

type parserImpl struct {
}

func New() *parserImpl <span class="cov8" title="1">{
        return &amp;parserImpl{}
}</span>

func (p *parserImpl) Parse(r *http.Request) (*metric.Metric, error) <span class="cov8" title="1">{
        switch r.Header.Get("content-type") </span>{
        case "application/json":<span class="cov0" title="0">
                return parseMetricByJSONBody(r)</span>
        default:<span class="cov8" title="1">
                return parseMetricByURLParams(r)</span>
        }
}

func (p *parserImpl) BatchParse(r *http.Request) ([]*metric.Metric, error) <span class="cov0" title="0">{
        switch r.Header.Get("content-type") </span>{
        case "application/json":<span class="cov0" title="0">
                return parseBatchMetricByJSONBody(r)</span>
        default:<span class="cov0" title="0">
                return nil, errors.New("incompatible content type for batch request")</span>
        }
}

func parseMetricByURLParams(r *http.Request) (*metric.Metric, error) <span class="cov8" title="1">{
        kind := metric.Kind(chi.URLParam(r, "kind"))
        name := chi.URLParam(r, "name")
        valueStr := chi.URLParam(r, "value")

        if err := checkName(name); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := checkKind(kind); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">m := &amp;metric.Metric{Type: kind, ID: name}

        if valueStr != "" </span><span class="cov8" title="1">{
                delta, value, err := codec.Encode(kind, valueStr)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">m.Delta = delta
                m.Value = value</span>
        }

        <span class="cov8" title="1">return m, nil</span>
}

func parseMetricByJSONBody(r *http.Request) (*metric.Metric, error) <span class="cov0" title="0">{
        data, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading body from request, err=%w", err)
        }</span>

        <span class="cov0" title="0">metricMsg, err := metric.Desirialize(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("metric desirialization err=%w", err)
        }</span>

        <span class="cov0" title="0">metric, err := parseMetricByJSONBodyImpl(metricMsg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse data=%v, err=%w", data, err)
        }</span>

        <span class="cov0" title="0">return metric, nil</span>
}

func parseBatchMetricByJSONBody(r *http.Request) ([]*metric.Metric, error) <span class="cov0" title="0">{
        data, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading body from request, err=%w", err)
        }</span>

        <span class="cov0" title="0">batchMetric := metric.NewBatch()
        if err := batchMetric.Deserialize(data); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("batch metric desirialization err=%w", err)
        }</span>

        <span class="cov0" title="0">metrics := make([]*metric.Metric, 0, batchMetric.Len())
        err = batchMetric.Foreach(func(nextMetric *metric.Metric) error </span><span class="cov0" title="0">{
                m, internalErr := parseMetricByJSONBodyImpl(nextMetric)
                if internalErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("parse metric err=%w", err)
                }</span>

                <span class="cov0" title="0">metrics = append(metrics, m)
                return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse batch data=%v, err=%w", data, err)
        }</span>

        <span class="cov0" title="0">return metrics, nil</span>
}

func parseMetricByJSONBodyImpl(metric *metric.Metric) (*metric.Metric, error) <span class="cov0" title="0">{
        if err := checkName(metric.ID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("check name metric=%v, err=%w", metric, err)
        }</span>

        <span class="cov0" title="0">if err := checkKind(metric.Type); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return metric, nil</span>
}

func checkName(name string) error <span class="cov8" title="1">{
        if name == "" </span><span class="cov8" title="1">{
                return ErrMetricNameIsNotFound
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func checkKind(kind metric.Kind) error <span class="cov8" title="1">{
        if kind != metric.Counter &amp;&amp; kind != metric.Gauge </span><span class="cov8" title="1">{
                return ErrBadMetricKind
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
